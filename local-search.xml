<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java:访问修饰符及相关概念</title>
    <link href="/2020/03/10/Java:%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/03/10/Java:%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java：访问修饰符及相关概念"><a href="#Java：访问修饰符及相关概念" class="headerlink" title="Java：访问修饰符及相关概念"></a>Java：访问修饰符及相关概念</h1><br><h2 id="四个修饰符基本概念"><a href="#四个修饰符基本概念" class="headerlink" title="四个修饰符基本概念"></a>四个修饰符基本概念</h2><br><h3 id="访问权限："><a href="#访问权限：" class="headerlink" title="访问权限："></a>访问权限：</h3><p><strong>public &gt; protected &gt; default &gt; private</strong></p><br><ul><li>public ——访问权限最大的修饰符，被它修饰的类、属性和方法可以在本类内部、别的类中以及别的包中使用。</li><li>protected ——访问权限介于public和private之间，被它修饰的属性和方法能被本类内部、本包中的其他类以及继承于本类的子类（子类可以是在别的包）使用。</li><li>default ——使用时可以省略（即在定义属性和方法时如果不加任何修饰符就等于使用default修饰）。它和protected修饰符的唯一区别就是protected可以被别的包中继承与本类的子类使用，而default只要是别的包的类（无论是不是子类）都不能使用。</li><li>private ——访问权限最小的修饰符，被它修饰的属性和方法只能用于本类内部。</li></ul><br><blockquote><p>这里有一点要注意，一个类中有一个用protected修饰的属性（方法也同理），继承于这个类但并不在同一个包中的子类能够使用它这个父类中的这个属性（protected），其实并不是通过创建这个父类的实例来使用的，而是使用子类自己的这个属性（其实也是它爸给它的）。换句话说，就是子类继承了父类中除了用private修饰的属性和方法之外的其他的属性和方法（包括public、proected，但没有default）,因此它才能在别的包中使用父类继承给它的这个它自己的protected属性（或方法）。而就是不能继承父类default属性（或方法）这一点导致default和protected的不同，同样都是别的包中的子类，protected能给子类而default却不给（出门在外的儿子不准拥有！）。</p></blockquote><br><p><strong>父类C1( <code>protected</code> 属性)，子类C2</strong><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco3ekzdobj312i0saq9a.jpg" srcset="/img/loading.gif" alt=""></p><br><p><strong>父类C1( <code>default</code> 属性)，子类C2</strong><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco3glzubdj31260ta7b1.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>在定义属性和方法时，应尽量使用访问权限小修饰词，根据情况权限给到够用就行</p></blockquote><br><h2 id="静态-static"><a href="#静态-static" class="headerlink" title="静态 static"></a>静态 static</h2><ul><li>静态变量</li></ul><p>类中的静态变量是不属于类的对象或实例的，只能以<code>[类名].[变量名]</code>这样的方式使用。定义静态变量时常和final一起使用，表示一个全局通用的恒量。</p><ul><li>静态方法</li></ul><p>静态方法同样也是不属于类的对象或实例，也只能以<code>[类名].[方法名]</code>的方式使用。静态方法内部只能调用静态变量和静态方法，Java中工具类中有很多静态方法。</p><ul><li>静态类</li></ul><p>Java中静态类是不能作为顶层类的，只能作为内部类（嵌套类）使用，也就是静态内部类。由于有了静态和内部双身份，导致它比较特殊，有以下几个特点：</p><ol><li>静态内部类里的静态成员（变量或方法）可以在外部类没有创建对象或实例时被别的类调用，这一点是静态类的体现，调用方式：<code>[外部类].[静态内部类].[静态成员]</code>。</li><li>静态内部类里可以有非静态的成员，调用的方式便是通过创建<strong>外部类的对象</strong>来调用。<em>这里需要注意，外部类拥有调用内部类所有成员（包括private成员）的权限，至于内部类是非静态还是静态的区别也就是对应在外部类调用时要创建内部类对象和不用创建内部类对象的区别。</em></li><li>静态内部类可以引用外部类的成员，但必须是静态的成员。</li><li>非静态内部类里面是不能定义静态成员的。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/03/08/my-first-blog-article/"/>
    <url>/2020/03/08/my-first-blog-article/</url>
    
    <content type="html"><![CDATA[<h3 id="随便写点什么，记录一下"><a href="#随便写点什么，记录一下" class="headerlink" title="随便写点什么，记录一下"></a>随便写点什么，记录一下</h3><p>作为一个不大会说话，从小就对文字语言不感冒的人，一直以来都是被动的输入，很少想着主动输出点什么（确实也没什么好说的…），但偶尔也会莫名其妙想写点东西。而博客这个早在我只知道上网能打游戏、聊天的时期就已经出现的词，这么个优雅的上网冲浪的方式，我居然到现在才真正用上它，哎，真不知道之前我都在网上瞎浪荡什么…以后这里就是我的composespace了，想到什么就写点什么吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
