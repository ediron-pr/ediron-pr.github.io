<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于http协议与安全传输</title>
    <link href="/2020/04/03/%E5%85%B3%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93/"/>
    <url>/2020/04/03/%E5%85%B3%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="关于http-https协议与安全传输"><a href="#关于http-https协议与安全传输" class="headerlink" title="关于http/https协议与安全传输"></a>关于http/https协议与安全传输</h1><br><blockquote><p>最近网上冲浪时，发现了一些大佬的宝藏博客，马上收藏起来，刚好自己最近也在看”<em>计算机网络自顶向下方法</em> “这本经典书，这篇文章就用于总结计算机网络相关知识，水平有限还在学习，会持续更新。</p></blockquote><br><br><h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><br><h3 id="HTTP-HyperText-Transfer-Protocol-：超文本传输协议"><a href="#HTTP-HyperText-Transfer-Protocol-：超文本传输协议" class="headerlink" title="HTTP(HyperText Transfer Protocol)：超文本传输协议"></a>HTTP(HyperText Transfer Protocol)：超文本传输协议</h3><p>顾名思义，HTTP协议设计最初的目的是用来提供一种发送和接收HTML（<em>HyperText Markup Language</em>）页面的方法，是万维网（<em>World Wide Web</em>）数据通信的基础。</p><p>HTTP是基于TCP\IP协议的应用层协议，它不涉及数据包（<em>packet</em>）传输，主要规定了客户端和服务器之间的通信格式，默认端口为80。</p><blockquote><p> 关于HTTP协议的发展详解，可以看阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">这篇文章</a>，通俗易懂深入浅出。</p></blockquote><br><h3 id="HTTPS-HyperText-Transfer-Protocol-Secure-：超文本传输安全协议"><a href="#HTTPS-HyperText-Transfer-Protocol-Secure-：超文本传输安全协议" class="headerlink" title="HTTPS(HyperText Transfer Protocol Secure)：超文本传输安全协议"></a>HTTPS(HyperText Transfer Protocol Secure)：超文本传输<u>安全</u>协议</h3><p>HTTPS（<em>又称为HTTP over TSL、HTTP over SSL、HTTP Secure</em>）是HTTP的升级版，经由HTTP进行通信，但利用了SSL/TSL来加密数据包。</p><p>HTTPS开发的目的是，提供对网站服务器的身份验证，保护交换数据的隐私与完整性。主要作用是在不安全的网络上创建一个安全信道，并可在使用适当的加密包和服务器证书可被验证与信任时，对窃听和中间人攻击提供合理的防护，默认端口为443。</p><br><br><hr><p>HTTP协议被用于在Web浏览器和Web服务器之间传输信息，但是是以明文方式传输的，没有使用任何加密，因此一旦有攻击者在传输过程中截取了传输报文，便能直接获取其中的信息，因此HTTP协议不能用于传输如银行账户密码此类敏感信息。</p><p>为了解决HTTP协议这一缺陷，1994年网景公司（<em>Netscape</em>）推出了在HTTP的基础上加入SSL协议（<em>Secure Socket Layer：安全套接层协议</em>）的HTTP的安全版HTTPS，而后被IETF（<em>Internet Engineering Task Force：因特网工程任务组</em>）将SSL进行了标准化，于1997年公布了第一版TLS协议。</p><br><br><h3 id="SSL-TSL协议运行机制"><a href="#SSL-TSL协议运行机制" class="headerlink" title="SSL/TSL协议运行机制"></a>SSL/TSL协议运行机制</h3><br><h4 id="SSL-TSL协议主要有这个作用："><a href="#SSL-TSL协议主要有这个作用：" class="headerlink" title="SSL/TSL协议主要有这个作用："></a>SSL/TSL协议主要有这个作用：</h4><ol><li>加密传输（对传输的信息进行加密，就算攻击者截取到了信息也很难知道信息的内容）</li><li>校验机制（通信双方可以对传输的数据进行校验，检验数据是否被篡改）</li><li>身份验证（主要是通过证书对服务器的真实性进行验证，防止身份被冒充）</li></ol><br><h4 id="SSL-TLS发展史："><a href="#SSL-TLS发展史：" class="headerlink" title="SSL/TLS发展史："></a>SSL/TLS发展史：</h4><ol><li>1994年网景公司（<em>Netscape</em>）设计了<code>SSL 1.0</code>，但是由于存在严重安全漏洞，一直未公开过</li><li>1995年发布了<code>SSL 2.0</code>，但也存在数个严重漏洞</li><li>1996年发布了<code>SSL 3.0</code></li><li>1999年IETF基于<code>SSL 3.0</code>标准化为<code>TLS 1.0</code>，两者差距微小，<code>TLS 1.0</code>中包含了可以通过降级到<code>SSL 3.0</code>来窃取信息的漏洞</li><li>2006年更新到<code>TLS 1.1</code>，而Microsoft、Google、Apple和Mozilla四家公司浏览器宣布将在2020年终止支持<code>TLS 1.0</code>和<code>TLS 1.1</code>版</li><li>2008年更新了<code>TLS 1.2</code></li><li>2018年发表了<code>TLS 1.3</code></li></ol><br><h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h4><blockquote><p> 为了更深刻地理解SSL/TLS协议的运行过程，有必要先来了解一下对称加密与非对称加密的区别。</p></blockquote><br><p><strong>对称加密：</strong>所谓对称就是通信双方都使用<u>同一把密钥</u>对要传输的信息进行<u>加密和解密</u>。</p><p><strong>非对称加密：</strong>非对称即是加密和解密使用<u>不同的密钥</u>，一把为公钥，一把为私钥。用公钥加密的信息，只能私钥才能解密；而用私钥加密的信息，也只有公钥能解密。一般服务器保留着私钥不公开，只给向它请求服务的客户端发送公钥，这样就做到了服务器发送的用私钥加密的信息只有持有公钥的客户端能解密读取，而客户端用公钥加密的信息也只能是服务器来解密读取。最常用的非对称加密算法就是RSA。</p><br><ul><li>对称加密<strong>优点</strong>：加密和解密效率较高、速度快</li><li>对称加密<strong>缺点</strong>：一般都需要将对称密钥通过线路传输给另一方，在传输途中有被截取的风险，不是很安全</li></ul><ul><li>非对称加密<strong>优点</strong>：因为私钥始终是不公开的，所以安全性较高</li><li>非对称加密<strong>缺点</strong>：加密和解密比较费时、效率低，只适合对少量数据加密</li></ul><br><blockquote><p>那么SSL/TLS协议到底要使用哪种加密方式，才能既安全又高效呢？答案是：都使用，结合起来使用😬。</p></blockquote><br><br><h4 id="SSL-TLS运行过程："><a href="#SSL-TLS运行过程：" class="headerlink" title="SSL/TLS运行过程："></a>SSL/TLS运行过程：</h4><blockquote><p>由于客户端与服务器建立连接后，会进行多次且大量的数据传输，如果使用非对称加密的话效率太低，因此只能使用对称加密来提高传输速度（<em>其实减少的时间主要体现在加解密的过程</em>），再能够避免在线路上传输对称密钥的话，就做到了既安全又高效了。</p></blockquote><br><p>在进行加密通信之前，客户端和服务器需要进行参数的交换以建立连接，这个过程叫作握手（<em>handshake</em>）。</p><p>先来用一张图来简单的说明一下，假设客户端是左边这位女士「Alice」，服务器是右边这位男士「Bob」：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gde2krhf91g30lc0jw3zq.gif" srcset="/img/loading.gif" alt=""></p><h5 id="整个过程大致分为五步："><a href="#整个过程大致分为五步：" class="headerlink" title="整个过程大致分为五步："></a>整个过程大致分为五步：</h5><ol><li>Alice作为客户端给服务器Bob发送一个对话请求，报文内容包括了客户端使用的协议版本号、想要访问的网站域名、支持的加密算法以及一个客户端生成的随机数（<em>client random</em>）。</li><li>服务器Bob收到客户端Alice的请求后，根据Alice支持的算法决定双方使用的加密方法，并给出数字证书（<em>内含公钥</em>）和一个服务器生成的随机数（<em>server random</em>）。</li><li>Alice在确认证书真实有效后，从证书中取出服务器公钥，并再生成一个新的随机数（<em>pre-master secret</em>）使用公钥加密后发送给服务器Bob。</li><li>Bob收到Alice用公钥加密后的随机数（<em>pre-master secret</em>）后，使用自己的私钥进行解密。</li><li>到此，客户端Alice和服务器Bob都各自保留有三个随机数（<em>两个客户端生成的、一个服务器生成的</em>），双方使用这三个随机数生成一个「对话密钥」（<em>session key</em>），使用它来加密后续的对话，握手结束。</li></ol><br><blockquote><p>从上面的握手过程可以看出，服务器的私钥和公钥加密就是非对称加密RSA算法，它只会在建立连接的过程中使用一次，而关键作用就在于<u>对客户端给服务器发送的第三个随机数（<em>pre-master secret</em>）进行加密</u>，从而使生成的「对话密钥」安全性得到保障。而握手完成后的数据传输全部靠这把「对话密钥」进行加密，这也就是对称加密。非对称加密的效率低资源消耗大，所以只使用一次来建立连接，而数据的大量传输使用对称加密速度快资源消耗小；对称加密的协商和生成在线路传输上有被盗风险，而使用非对称加密来保护对称加密的生成过程来避免暴露。综上所述，我们利用了对称加密和非对称加密各自的优点分别来弥补对方的缺点，合理地配合使用加密算法。</p></blockquote><br><h5 id="这里需要解释一下为什么一定要用-三个-随机数来生成「对话密钥」："><a href="#这里需要解释一下为什么一定要用-三个-随机数来生成「对话密钥」：" class="headerlink" title="这里需要解释一下为什么一定要用 三个 随机数来生成「对话密钥」："></a>这里需要解释一下为什么一定要用 三个 随机数来生成「对话密钥」：</h5><ol><li>首先随机数的引入，很大程度提高了SSL/TLS协议的安全性。因为证书是静态的，而一尘不变肯定没有随机变化更让人难以揣测，这就好比我们平时登录帐号时使用的「密码」和「验证码」的区别，密码是静态的（<em>当然不是不能修改的意思</em>），而验证码是实时变化的。所以引入随机因素能够保证协商生成出来的密钥的随机性。</li><li>而引入的主要随机数就是被加密传输的第三个随机数（<em>pre-master secret</em>），那前面在客户端和服务器「打招呼」中生成的两个随机数有什么用呢？因为我们不能保证通信的双方主机之一（<em>客户端或服务器</em>）能正常生成「真正随机」的随机数，如果生成的唯一的随机数（pre-master secret）并不随机，就很可能被破解。这样在双方都参与的情况下生成三个随机数，三个随机数都不随机的情况发生的概率几乎为0，因为这种情况本身就很随机。</li></ol><br><br><h4 id="CloudFlare与SSL"><a href="#CloudFlare与SSL" class="headerlink" title="CloudFlare与SSL"></a>CloudFlare与SSL</h4><br><h5 id="CDN（Content-Distribution-Network）内容分发网络"><a href="#CDN（Content-Distribution-Network）内容分发网络" class="headerlink" title="CDN（Content Distribution Network）内容分发网络"></a>CDN（<em>Content Distribution Network</em>）内容分发网络</h5><p>内容分发网络CDN是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地讲影音、图片、应用程序等文件发送给用户，提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p><strong>CloudFlare</strong>就是知名的CDN服务提供商，在全球拥有许多连线到互联网交换点的连线，CloudFlare将网站内容缓存到自己的服务器上，以扮演内容提供网络（<em>CDN</em>）的角色，所有要求会透过CloudFlare进行反向代理，并直接从CloudFlare提供缓存的内容。</p><p>CloudFlare在14年9月发布了一种新型加密传输技术——<strong>无密钥SSL</strong>（<em>Keyless SSL</em>）。在该技术的支持下，CloudFlare可以在不持有客户私钥的情况下与访客创建SSL连接，这使得银行这种无法交予私钥的服务器用户现在也可以享受最大限度的安全服务。</p><br><h5 id="CloudFlare官方介绍"><a href="#CloudFlare官方介绍" class="headerlink" title="CloudFlare官方介绍"></a>CloudFlare官方介绍</h5><br><h6 id="①不使用「Keyless-SSL」的SSL握手过程（RSA）："><a href="#①不使用「Keyless-SSL」的SSL握手过程（RSA）：" class="headerlink" title="①不使用「Keyless SSL」的SSL握手过程（RSA）："></a>①不使用「Keyless SSL」的SSL握手过程（<em>RSA</em>）：</h6><p>也就是前面讲过的最原始的SSL协议运行过程，下图的「Visitor」就是「Alice」，「CloudFlare」就是「Bob」。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdfymvp5g6j30t80j0mz4.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>这种情况就是CloudFlare来代替内容提供商向客户端用户发送内容，而CloudFlare必须要拿到内容提供商的私钥，才能和客户端用户建立SSL安全连接。</p></blockquote><br><h6 id="②使用「Keyless-SSL」的SSL握手过程（RSA）："><a href="#②使用「Keyless-SSL」的SSL握手过程（RSA）：" class="headerlink" title="②使用「Keyless SSL」的SSL握手过程（RSA）："></a>②使用「Keyless SSL」的SSL握手过程（<em>RSA</em>）：</h6><p>使用CloudFlare的「Keyless SSL」后，当需要使用私钥解密的时候，再请求源服务器（<em>内容提供商</em>）用私钥解密，解密后再回送给CloudFlare服务器：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgt9b9zirj30qo09lmxg.jpg" srcset="/img/loading.gif" alt=""></p><p>其具体的实现细节如下图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdfyzznm3ij31rv0u0jwo.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>看不清可以点开图片开大图</p></blockquote><p>前面说到，在SSL握手过程中，服务器的公钥和私钥只用到了一次，而这便是「Keyless」能运作的关键。</p><p>在CloudFlare收到客户端发来的用公钥加密的第三个随机数（<em>pre-master secret</em>）后，将它转发给内容提供商存放私钥的服务器，私钥服务器解密后发回给CloudFlare服务器，便可以继续进行后面的操作。</p><p>要用「Alice」和「Bob」来解释，就如下图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdguol5mafg30vl0lhq4l.gif" srcset="/img/loading.gif" alt=""></p><br><br><br><br><br><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p>阮一峰老师博客：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS运行机制概述</a> 、<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><p>掘金博客：<a href="https://juejin.im/post/5abb6c8651882555784e051d" target="_blank" rel="noopener">对称加密与非对称加密</a>、<a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="noopener">HTTP与HTTPS</a></p><p>CloudFlare官网博客：<a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a>、<a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/" target="_blank" rel="noopener">Announcing Keyless SSL™: All the Benefits of CloudFlare Without Having to Turn Over Your Private SSL Keys</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java:访问修饰符及相关概念</title>
    <link href="/2020/03/10/Java:%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/03/10/Java:%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java：访问修饰符及相关概念"><a href="#Java：访问修饰符及相关概念" class="headerlink" title="Java：访问修饰符及相关概念"></a>Java：访问修饰符及相关概念</h1><br><h2 id="四个修饰符基本概念"><a href="#四个修饰符基本概念" class="headerlink" title="四个修饰符基本概念"></a>四个修饰符基本概念</h2><br><h3 id="访问权限："><a href="#访问权限：" class="headerlink" title="访问权限："></a>访问权限：</h3><p><strong>public &gt; protected &gt; default &gt; private</strong></p><br><ul><li>public ——访问权限最大的修饰符，被它修饰的类、属性和方法可以在本类内部、别的类中以及别的包中使用。</li><li>protected ——访问权限介于public和private之间，被它修饰的属性和方法能被本类内部、本包中的其他类以及继承于本类的子类（子类可以是在别的包）使用。</li><li>default ——使用时可以省略（即在定义属性和方法时如果不加任何修饰符就等于使用default修饰）。它和protected修饰符的唯一区别就是protected可以被别的包中继承与本类的子类使用，而default只要是别的包的类（无论是不是子类）都不能使用。</li><li>private ——访问权限最小的修饰符，被它修饰的属性和方法只能用于本类内部。</li></ul><br><blockquote><p>这里有一点要注意，一个类中有一个用protected修饰的属性（方法也同理），继承于这个类但并不在同一个包中的子类能够使用它这个父类中的这个属性（protected），其实并不是通过创建这个父类的实例来使用的，而是使用子类自己的这个属性（其实也是它爸给它的）。换句话说，就是子类继承了父类中除了用private修饰的属性和方法之外的其他的属性和方法（包括public、proected，但没有default）,因此它才能在别的包中使用父类继承给它的这个它自己的protected属性（或方法）。而就是不能继承父类default属性（或方法）这一点导致default和protected的不同，同样都是别的包中的子类，protected能给子类而default却不给（出门在外的儿子不准拥有！）。</p></blockquote><br><p><strong>父类C1( <code>protected</code> 属性)，子类C2</strong><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco3ekzdobj312i0saq9a.jpg" srcset="/img/loading.gif" alt=""></p><br><p><strong>父类C1( <code>default</code> 属性)，子类C2</strong><br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gco3glzubdj31260ta7b1.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>在定义属性和方法时，应尽量使用访问权限小修饰词，根据情况权限给到够用就行</p></blockquote><br><h2 id="静态-static"><a href="#静态-static" class="headerlink" title="静态 static"></a>静态 static</h2><ul><li>静态变量</li></ul><p>类中的静态变量是不属于类的对象或实例的，只能以<code>[类名].[变量名]</code>这样的方式使用。定义静态变量时常和final一起使用，表示一个全局通用的恒量。</p><ul><li>静态方法</li></ul><p>静态方法同样也是不属于类的对象或实例，也只能以<code>[类名].[方法名]</code>的方式使用。静态方法内部只能调用静态变量和静态方法，Java中工具类中有很多静态方法。</p><ul><li>静态类</li></ul><p>Java中静态类是不能作为顶层类的，只能作为内部类（嵌套类）使用，也就是静态内部类。由于有了静态和内部双身份，导致它比较特殊，有以下几个特点：</p><ol><li>静态内部类里的静态成员（变量或方法）可以在外部类没有创建对象或实例时被别的类调用，这一点是静态类的体现，调用方式：<code>[外部类].[静态内部类].[静态成员]</code>。</li><li>静态内部类里可以有非静态的成员，调用的方式便是通过创建<strong>外部类的对象</strong>来调用。<em>这里需要注意，外部类拥有调用内部类所有成员（包括private成员）的权限，至于内部类是非静态还是静态的区别也就是对应在外部类调用时要创建内部类对象和不用创建内部类对象的区别。</em></li><li>静态内部类可以引用外部类的成员，但必须是静态的成员。</li><li>非静态内部类里面是不能定义静态成员的。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/03/08/my-first-blog-article/"/>
    <url>/2020/03/08/my-first-blog-article/</url>
    
    <content type="html"><![CDATA[<h3 id="随便写点什么，记录一下"><a href="#随便写点什么，记录一下" class="headerlink" title="随便写点什么，记录一下"></a>随便写点什么，记录一下</h3><p>作为一个不善言辞，从小就对文字语言不感冒的人，一直以来都是被动的输入，很少想着主动输出点什么（确实也没什么好说的…），但偶尔也会莫名其妙想写点东西。而博客这个早在我只知道上网能打游戏、聊天的时期就已经出现的词，这么个优雅的上网冲浪的方式，我居然到现在才真正用上它，哎，真不知道之前我都在网上瞎浪荡什么…以后这里就是我的compose space了，想到什么就写点什么吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
