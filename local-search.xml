<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线程安全：继承类方式和实现接口方式以及同步代码块和同步方法的相关使用</title>
    <link href="/2020/05/28/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A%E7%BB%A7%E6%89%BF%E7%B1%BB%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/28/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A%E7%BB%A7%E6%89%BF%E7%B1%BB%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>需求：有两个线程，一个打印奇数，一个打印偶数，两个线程启动后，每次打印都必须是连续5个奇数或连续5个偶数，奇偶之间的交替不作要求。</p><br><p><strong>①继承类+同步代码块</strong></p><p>继承两个「Thread」类，分别实现打印奇数和偶数的方法，将打印的代码加锁，每次只能是一个线程进行打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class Test0 &#123;</span><br><span class="line">&#x2F;&#x2F;继承Thread类方式，创建两种功能的Thread类：ThreadOdd、ThreadEven</span><br><span class="line">&#x2F;&#x2F;并使用「字符串同步锁」保证线程安全</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建奇、偶功能的线程</span><br><span class="line">new ThreadOdd().start();</span><br><span class="line">new ThreadEven().start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;打印奇数的线程</span><br><span class="line">class ThreadOdd extends Thread&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;进入无限循环打印</span><br><span class="line">while(true) &#123;</span><br><span class="line">&#x2F;&#x2F;通过「字符串同步锁」来实现不同类的线程之间的互斥访问</span><br><span class="line">&#x2F;&#x2F;使得每次只能有一个线程在打印</span><br><span class="line">synchronized (&quot;print&quot;) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;连续打印5个奇数</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;每次打印间隔0.1秒</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">System.out.println(i+&quot; Printing Odd...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每打印5个空一行</span><br><span class="line">System.out.println();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;打印偶数的线程</span><br><span class="line">class ThreadEven extends Thread&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;进入无限循环打印</span><br><span class="line">while(true) &#123;</span><br><span class="line">&#x2F;&#x2F;通过「字符串同步锁」来实现不同类的线程之间的互斥访问</span><br><span class="line">&#x2F;&#x2F;使得每次只能有一个线程在打印</span><br><span class="line">synchronized (&quot;print&quot;) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;连续打印5个偶数</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;每次打印间隔0.1秒</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">System.out.println(i+&quot; Printing Even...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每打印5个空一行</span><br><span class="line">System.out.println();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个例子验证了，即使在是不同的类中，只要同步代码块的锁对象相同（上例中都使用字符串「print」作为锁对象），就能对代码进行锁定。</p></blockquote><br><p>这样看来，『能在不同类中进行同步的操作』的依据是：可以使用「同步代码块」的「锁对象」，进行跨类锁定，不管<strong>线程对象</strong>是否是<strong>同类</strong>，只要「同步代码块」的「锁对象」一致，就能保证线程安全。</p><p>因此可以推测出，<strong>「同步方法」是不能进行跨类同步的</strong>，因为在『继承类的方式』中，同步方法的本质是『隐含的锁对象是类的Class对象』，所以<strong>不同类</strong>的线程的「Class对象」不一致，也就不能够满足方法的锁对象一致，正是这一点导致要进行<strong>跨类同步</strong>不能使用<strong>「同步方法」</strong>。（『实现接口的方式』就更不可能使用「同步方法」了）</p><br><p>而要想两个线程实现不同的功能，就只能是使用『继承类的方式』来创建线程。因为『实现接口的方式』创建的「Target」对象都是同一个类，而用其创建出的「Thread」对象都是同样的实现功能，无法满足不同线程实现不同功能的需求。</p><br><p>不过也是可以强行使用『实现接口的方式』的：</p><p>创建两个不同功能的「Target」对象，再分别用这两个「Target」对象创建两个「Thread」类，这样是可以达到『不同功能的线程实现同步锁』的需求的，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现Runnable接口方式，分别用两种功能的Target来创建对应两种功能的Thread类：TargetOdd、TargetEven</span><br><span class="line">&#x2F;&#x2F;并使用「字符串同步锁」保证线程安全</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用奇偶功能的Target分别创建奇、偶线程</span><br><span class="line">new Thread(new TargetOdd()).start();</span><br><span class="line">new Thread(new TargetEven()).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;打印奇数的Target</span><br><span class="line">class TargetOdd implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;进入无限打印循环</span><br><span class="line">while(true) &#123;</span><br><span class="line">&#x2F;&#x2F;通过「字符串同步锁」来实现不同类的线程之间的互斥访问</span><br><span class="line">&#x2F;&#x2F;使得每次只能有一个线程在打印</span><br><span class="line">synchronized (&quot;print&quot;) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;连续5次打印</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">System.out.println(i+&quot; Printing Odd...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每5个空一行</span><br><span class="line">System.out.println();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;打印偶数的Target</span><br><span class="line">class TargetEven implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;进入无限打印循环</span><br><span class="line">while(true) &#123;</span><br><span class="line">&#x2F;&#x2F;通过「字符串同步锁」来实现不同类的线程之间的互斥访问</span><br><span class="line">&#x2F;&#x2F;使得每次只能有一个线程在打印</span><br><span class="line">synchronized (&quot;print&quot;) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;连续5次打印</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">System.out.println(i+&quot; Printing Even...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每5个空一行</span><br><span class="line">System.out.println();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过这样做的意义不大，甚至可能没必要这样做，因为这跟上面『继承类的方式』的原理一样，都是通过创建两个不同的「Thread」类来区分功能的。</p></blockquote><br><p><strong>综上所述，要实现这个需求（不同功能的线程在运行时保证线程安全），其关键两点是①两个线程分别实现两种功能②两个线程的功能还要保持互斥访问（线程安全）。第①点通过两个继承「Thread」类来实现不同功能，第②点通过同步代码块的「字符串锁对象」来实现互斥访问。</strong></p><br><p>那么要想实现<strong>不同功能的线程</strong>的<strong>线程安全问题</strong>，就只能使用『继承类的方式』+『同步代码块』这个组合吗？</p><br><p>其实还可以有另外一种思路，这种思路解放了前面被种种限制的方式。</p><p>这种思路是我在思考这个需求时最初就想到的（说实话，其实是因为我当时根本不知道还能有跨类同步这种操作），而当时我的想法是：实现同步的前提就是对两个线程的<strong>执行代码</strong>进行<strong>「加锁」</strong>，而要<strong>「加锁」</strong>就只能是让两个线程对象属于同一个类，这样才能使它们共用同一个被<strong>「加锁」</strong>代码。</p><p>但是，顾此就会失彼，让两个线程共用同一个「同步代码块」就无法达到分别实现它们各自的功能，真的无法吗？既然只能共用「同步代码块」，那么进入代码块之后有什么可以用来判断区分两个线程呢？<strong>名字！</strong>我突然想起线程是有名字的！这样问题就可以解决了。</p><br><p>根据这个思路，我们使用实现类也是可以做到的，使用同样的「Target」创建的两个「Thread」对象，进入到同步代码块之后，再根据各自的名字判断执行对应的功能（打印奇、偶）。</p><p><strong>②实现接口+同步代码块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现Runnable接口方式，用一个内部有两种功能的Target创建Thread类：Target1</span><br><span class="line">&#x2F;&#x2F;并使用「当前对象同步锁」保证线程安全</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;创建内部有两种功能的Target</span><br><span class="line">Target1 myTarget &#x3D; new Target1();</span><br><span class="line">&#x2F;&#x2F;使用同一个Target创建奇、偶线程</span><br><span class="line">new Thread(myTarget, &quot;奇数&quot;).start();</span><br><span class="line">new Thread(myTarget, &quot;偶数&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Target1 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F;进入无限打印循环</span><br><span class="line">while(true) &#123;</span><br><span class="line">&#x2F;&#x2F;每次循环只能有一个线程在打印，并且连续打印5个，再进入下一次循环</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">&#x2F;&#x2F;连续打印5个</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 奇数线程</span><br><span class="line">&#x2F;&#x2F;如果是奇数线程，就打印奇数</span><br><span class="line">if (&quot;奇数&quot;.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">&#x2F;&#x2F;省略打印奇数细节</span><br><span class="line">System.out.println(i+&quot; Printing Odd...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 偶数线程</span><br><span class="line">&#x2F;&#x2F;如果是偶数线程，就打印偶数</span><br><span class="line">if (&quot;偶数&quot;.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">&#x2F;&#x2F;省略打印偶数细节</span><br><span class="line">System.out.println(i+&quot; Printing Even...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每打印一个，停顿0.1秒</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每打印5个空一行</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然代码有些繁琐，可读性有点低，但确实是可以实现这个需求的，这样就不用非要使用两个类来实现不同的功能。</p></blockquote><br><p>前面说到，由于「同步方法」不能用于跨类同步，那么就不让它跨类呗。这个思路的好处就是，不管是使用『继承类的方式』还是『实现接口的方式』，都让线程进入到同步区域内再做判断，还是根据线程的名字决定其执行的功能。</p><p><strong>③实现接口+同步方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实现Runnable接口方式，用一个内部有两种功能的Target创建Thread类：Target2</span><br><span class="line">&#x2F;&#x2F;并使用静态「同步方法」保证线程安全</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Target2 oneTarget &#x3D; new Target2();</span><br><span class="line">new Thread(oneTarget, &quot;奇数&quot;).start();</span><br><span class="line">new Thread(oneTarget, &quot;偶数&quot;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Target2 implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用打印方法</span><br><span class="line">while(true) &#123;</span><br><span class="line">print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized static void print() &#123;</span><br><span class="line">&#x2F;&#x2F;连续打印5个</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 奇数线程</span><br><span class="line">&#x2F;&#x2F;如果是奇数线程，就打印奇数</span><br><span class="line">if (&quot;奇数&quot;.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">&#x2F;&#x2F;省略打印奇数细节</span><br><span class="line">System.out.println(i+&quot; Printing Odd...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 偶数线程</span><br><span class="line">&#x2F;&#x2F;如果是偶数线程，就打印偶数</span><br><span class="line">if (&quot;偶数&quot;.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">&#x2F;&#x2F;省略打印偶数细节</span><br><span class="line">System.out.println(i+&quot; Printing Even...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每打印一个，停顿0.1秒</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;每打印5个空一行</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然使用了这个思路后，两种实现接口的方式也可以解决问题，但应该还是没有第一种『继承类+同步代码块』效率高，所以推荐使用第一种方式。</p></blockquote><br><br><br><p><strong>最后作一些总结：</strong></p><ol><li><strong>『继承类的方式』更适用于创建不同功能的线程</strong></li><li><strong>『实现接口的方式』更适用于创建同样功能的线程</strong></li><li><strong>「同步代码块」更适用于不同功能的线程</strong></li><li><strong>「同步方法」更适用于同样功能的线程</strong></li></ol><br><p>解决问题的方法有很多，而具体方案还要根据具体问题进行分析。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>technology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中没有值传递</title>
    <link href="/2020/05/07/Java%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <url>/2020/05/07/Java%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中只有值传递"><a href="#Java中只有值传递" class="headerlink" title="Java中只有值传递"></a>Java中只有值传递</h1><br><br><p>Java只有「值传递」一种传参方式，并没有真正意义上的引用传递。「值传递」和传递「值类型」(或者说「基本数据类型」)，并不是相对应的；同样的「引用传递」和传递「引用类型」也完全不是一个概念。而这与以往我的认识中『引用类型的传递就是引用传递』相悖，那是因为之前我根本没有搞清楚什么是值传递什么是引用传递。</p><br><br><blockquote><p><strong>值传递和引用传递，属于函数调用时参数的求值策略(Evaluation Strategy)，这是对调用函数时，求值和传值的方式的描述，而非传递的内容的类型。</strong>值类型和引用类型，是用于区分两种内存分配方式，值类型在调用栈上分配，引用类型在堆上分配。一个描述内存分配方式，一个描述参数求值策略，两者之间无任何依赖或约束关系。</p></blockquote><br><p>换句话说，也就是「值传递」和「值类型」，「引用传递」和「引用类型」并不是两两捆绑的概念。而其中的困惑就是『Java中引用类型的传递到底属于值传递还是引用传递？』，而文章标题就是答案，Java中引用类型的传递也是「值传递」。</p><br><p>所以，Java中只有「值传递」，值类型和引用类型都是「值传递」，那么引用类型的传递是怎么归属于「值传递」的呢？「引用传递」的实质又是怎样呢？</p><br><br><p><strong>首先来捋清几个概念：</strong></p><p>前面说到在进行方法调用时，从实参到形参的这个传参过程其实是程序设计中的<strong>求值策略（Evaluation Strategies）</strong>，它就是对传入表达式的值的一套处理规则（比如 <strong>求值时机</strong>：是在调用方法前还是调用方法后），通常『在调用方法前求值』这一类策略属于「严格求值」（另一类就是非严格求值），这也是大多数编程语言使用的求值策略。而我们「严格求值」中关心的规则就是「传值方式」。「值传递」和「引用传递」都是传值方式，它们的具体定义如下：</p><blockquote><ul><li>值传递（传值调用）</li></ul><p>在值传递中，实际参数先被求值，然后其值通过复制，被传递给被调函数的形式参数。因为形式参数拿到的只是一个”局部拷贝”，所以如果在被调函数中改变了形式参数的值，并不会改变实际参数的值。</p><ul><li>引用传递（传引用调用）</li></ul><p>在引用传递中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。因为传递的是引用，所以，如果在被调函数中改变了形式参数的值，改变对于调用者来说是可见的。</p></blockquote><br><blockquote><p> <strong>值传递是指在调用函数时将实际参数<code>复制</code>一份传递到函数中，引用传递是指在调用函数时将实际参数的引用<code>直接</code>传递到函数中</strong></p></blockquote><br><p>上述「引用传递」的描述中『传递给函数的是它的实际参数的隐式引用而不是实参的拷贝』这句话，是指「引用传递」其实就是直接把实参拿来用，是直接对实参进行操作，对实参的影响不仅限于对实参成员的修改，而且可以通过让实参变量指向另一个对象或者「null」，来修改实参变量的指向，这便是真正意义上的引用传递。</p><p>而Java中的引用类型的传递是传递了对象的引用地址，在方法中调用的是和实参变量指向同一个地址的形参变量，对形参所指对象的成员进行修改当然会影响到原本的实参对象，理论上它们是两个变量但是共用同一个数据空间。但是不管怎么样，对形参的指向进行修改，都不会影响到实参的指向，在方法内对于对象的影响就仅限于内容的修改，并不具有「引用传递」那样直接修改实参变量的能力。这就是Java中引用类型的传递与「引用传递」本质的区别，就可以排除引用类型的传递方式是「引用传递」的可能了。</p><br><br><p>既然引用类型在Java中不是「引用传递」方式，那就只能是「值传递」了。其实它是有自己的名字及定义的：</p><blockquote><ul><li>共享对象传递（传共享对象调用）</li></ul><p>共享对象传递中，先获取到实际参数的地址，然后将其复制，并把该地址的拷贝传递给被调函数的形式参数。因为参数的地址都指向同一个对象，所以我们称也之为”传共享对象”，所以，如果在被调函数中改变了形式参数的值，调用者是可以看到这种变化的。</p></blockquote><br><p>从定义的描述就可以看出，其关键步骤和「值传递」是一样的，都有「复制/拷贝」这么一步，只不过「值传递」在传递 值类型 的时候，复制/拷贝的是实际的值（内容），而传递引用类型时（就叫共享对象传递），复制/拷贝的就是参数对象的地址了。其实仔细想想，「地址」也是值啊，把地址的传递也归属于「值传递」没毛病。所以，通常我们认为「共享对象传递」时「值传递」的特例。</p><br><blockquote><p>对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本，不同的是，对于值类型而言，这个副本就是整个原始值的复制。而对于引用类型而言，由于引用类型的实例在堆中，在栈上只有它的一个引用，其副本也只是这个引用的复制，而不是整个原始对象的复制。</p><p><strong>这便引出了值类型和引用类型的最大区别：值类型用做参数会被复制，但是很多人误以为这个区别是值类型的特性。其实这是==值传递==带来的效果，和值类型本身没有关系。</strong> </p></blockquote><br><p>这样，我们总共介绍了三种参数传递的形式，分别是「值传递」、「引用传递」和「共享对象传递」，它们的关系是，「值传递」是包含「共享对象传递」，即「共享对象传递」的本质就是「值传递」，它们传递的核心过程都一样；而「引用传递」与「共享对象传递」的结果很相似，都可以通过对形参的操作影响到原本的实参，但实现方式是截然不同的。</p><br><br><p>以上便是对文章标题这个以前一直不清楚的事实的解析，在想搞懂搞明白一个概念之前，需要将这个概念进行拆解，它一定由一些基础概念或细节组成，在对这些有了一定的了解后，大的概念自然也就知其所以然了。</p><br><br><br><h4 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h4><p><a href="https://hollischuang.github.io/toBeTopJavaer/#/basics/object-oriented/why-pass-by-reference" target="_blank" rel="noopener">为什么说Java中只有值传递</a></p><p><a href="[http://chenwenbo.github.io/2016/05/11/%E5%85%B3%E4%BA%8E%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/](http://chenwenbo.github.io/2016/05/11/关于值传递和引用传递/)">关于值传递和引用传递</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>technology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于http协议与安全传输</title>
    <link href="/2020/04/03/%E5%85%B3%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93/"/>
    <url>/2020/04/03/%E5%85%B3%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<h1 id="关于http-https协议与安全传输"><a href="#关于http-https协议与安全传输" class="headerlink" title="关于http/https协议与安全传输"></a>关于http/https协议与安全传输</h1><br><blockquote><p>最近网上冲浪时，发现了一些大佬的宝藏博客，马上收藏起来，刚好自己最近也在看”<em>计算机网络自顶向下方法</em> “这本经典书，这篇文章就用于总结计算机网络相关知识，水平有限还在学习，会持续更新。</p></blockquote><br><br><h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><br><h3 id="HTTP-HyperText-Transfer-Protocol-：超文本传输协议"><a href="#HTTP-HyperText-Transfer-Protocol-：超文本传输协议" class="headerlink" title="HTTP(HyperText Transfer Protocol)：超文本传输协议"></a>HTTP(HyperText Transfer Protocol)：超文本传输协议</h3><p>顾名思义，HTTP协议设计最初的目的是用来提供一种发送和接收HTML（<em>HyperText Markup Language</em>）页面的方法，是万维网（<em>World Wide Web</em>）数据通信的基础。</p><p>HTTP是基于TCP\IP协议的应用层协议，它不涉及数据包（<em>packet</em>）传输，主要规定了客户端和服务器之间的通信格式，默认端口为80。</p><blockquote><p> 关于HTTP协议的发展详解，可以看阮一峰老师的<a href="https://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">这篇文章</a>，通俗易懂深入浅出。</p></blockquote><br><h3 id="HTTPS-HyperText-Transfer-Protocol-Secure-：超文本传输安全协议"><a href="#HTTPS-HyperText-Transfer-Protocol-Secure-：超文本传输安全协议" class="headerlink" title="HTTPS(HyperText Transfer Protocol Secure)：超文本传输安全协议"></a>HTTPS(HyperText Transfer Protocol Secure)：超文本传输<u>安全</u>协议</h3><p>HTTPS（<em>又称为HTTP over TSL、HTTP over SSL、HTTP Secure</em>）是HTTP的升级版，经由HTTP进行通信，但利用了SSL/TSL来加密数据包。</p><p>HTTPS开发的目的是，提供对网站服务器的身份验证，保护交换数据的隐私与完整性。主要作用是在不安全的网络上创建一个安全信道，并可在使用适当的加密包和服务器证书可被验证与信任时，对窃听和中间人攻击提供合理的防护，默认端口为443。</p><br><br><hr><p>HTTP协议被用于在Web浏览器和Web服务器之间传输信息，但是是以明文方式传输的，没有使用任何加密，因此一旦有攻击者在传输过程中截取了传输报文，便能直接获取其中的信息，因此HTTP协议不能用于传输如银行账户密码此类敏感信息。</p><p>为了解决HTTP协议这一缺陷，1994年网景公司（<em>Netscape</em>）推出了在HTTP的基础上加入SSL协议（<em>Secure Socket Layer：安全套接层协议</em>）的HTTP的安全版HTTPS，而后被IETF（<em>Internet Engineering Task Force：因特网工程任务组</em>）将SSL进行了标准化，于1997年公布了第一版TLS协议。</p><br><br><h3 id="SSL-TSL协议运行机制"><a href="#SSL-TSL协议运行机制" class="headerlink" title="SSL/TSL协议运行机制"></a>SSL/TSL协议运行机制</h3><br><h4 id="SSL-TSL协议主要有这个作用："><a href="#SSL-TSL协议主要有这个作用：" class="headerlink" title="SSL/TSL协议主要有这个作用："></a>SSL/TSL协议主要有这个作用：</h4><ol><li>加密传输（对传输的信息进行加密，就算攻击者截取到了信息也很难知道信息的内容）</li><li>校验机制（通信双方可以对传输的数据进行校验，检验数据是否被篡改）</li><li>身份验证（主要是通过证书对服务器的真实性进行验证，防止身份被冒充）</li></ol><br><h4 id="SSL-TLS发展史："><a href="#SSL-TLS发展史：" class="headerlink" title="SSL/TLS发展史："></a>SSL/TLS发展史：</h4><ol><li>1994年网景公司（<em>Netscape</em>）设计了<code>SSL 1.0</code>，但是由于存在严重安全漏洞，一直未公开过</li><li>1995年发布了<code>SSL 2.0</code>，但也存在数个严重漏洞</li><li>1996年发布了<code>SSL 3.0</code></li><li>1999年IETF基于<code>SSL 3.0</code>标准化为<code>TLS 1.0</code>，两者差距微小，<code>TLS 1.0</code>中包含了可以通过降级到<code>SSL 3.0</code>来窃取信息的漏洞</li><li>2006年更新到<code>TLS 1.1</code>，而Microsoft、Google、Apple和Mozilla四家公司浏览器宣布将在2020年终止支持<code>TLS 1.0</code>和<code>TLS 1.1</code>版</li><li>2008年更新了<code>TLS 1.2</code></li><li>2018年发表了<code>TLS 1.3</code></li></ol><br><h4 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h4><blockquote><p> 为了更深刻地理解SSL/TLS协议的运行过程，有必要先来了解一下对称加密与非对称加密的区别。</p></blockquote><br><p><strong>对称加密：</strong>所谓对称就是通信双方都使用<u>同一把密钥</u>对要传输的信息进行<u>加密和解密</u>。</p><p><strong>非对称加密：</strong>非对称即是加密和解密使用<u>不同的密钥</u>，一把为公钥，一把为私钥。用公钥加密的信息，只能私钥才能解密；而用私钥加密的信息，也只有公钥能解密。一般服务器保留着私钥不公开，只给向它请求服务的客户端发送公钥，这样就做到了服务器发送的用私钥加密的信息只有持有公钥的客户端能解密读取，而客户端用公钥加密的信息也只能是服务器来解密读取。最常用的非对称加密算法就是RSA。</p><br><ul><li>对称加密<strong>优点</strong>：加密和解密效率较高、速度快</li><li>对称加密<strong>缺点</strong>：一般都需要将对称密钥通过线路传输给另一方，在传输途中有被截取的风险，不是很安全</li></ul><ul><li>非对称加密<strong>优点</strong>：因为私钥始终是不公开的，所以安全性较高</li><li>非对称加密<strong>缺点</strong>：加密和解密比较费时、效率低，只适合对少量数据加密</li></ul><br><blockquote><p>那么SSL/TLS协议到底要使用哪种加密方式，才能既安全又高效呢？答案是：都使用，结合起来使用😬。</p></blockquote><br><br><h4 id="SSL-TLS运行过程："><a href="#SSL-TLS运行过程：" class="headerlink" title="SSL/TLS运行过程："></a>SSL/TLS运行过程：</h4><blockquote><p>由于客户端与服务器建立连接后，会进行多次且大量的数据传输，如果使用非对称加密的话效率太低，因此只能使用对称加密来提高传输速度（<em>其实减少的时间主要体现在加解密的过程</em>），再能够避免在线路上传输对称密钥的话，就做到了既安全又高效了。</p></blockquote><br><p>在进行加密通信之前，客户端和服务器需要进行参数的交换以建立连接，这个过程叫作握手（<em>handshake</em>）。</p><p>先来用一张图来简单的说明一下，假设客户端是左边这位女士「Alice」，服务器是右边这位男士「Bob」：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gde2krhf91g30lc0jw3zq.gif" srcset="/img/loading.gif" alt=""></p><h5 id="整个过程大致分为五步："><a href="#整个过程大致分为五步：" class="headerlink" title="整个过程大致分为五步："></a>整个过程大致分为五步：</h5><ol><li>Alice作为客户端给服务器Bob发送一个对话请求，报文内容包括了客户端使用的协议版本号、想要访问的网站域名、支持的加密算法以及一个客户端生成的随机数（<em>client random</em>）。</li><li>服务器Bob收到客户端Alice的请求后，根据Alice支持的算法决定双方使用的加密方法，并给出数字证书（<em>内含公钥</em>）和一个服务器生成的随机数（<em>server random</em>）。</li><li>Alice在确认证书真实有效后，从证书中取出服务器公钥，并再生成一个新的随机数（<em>pre-master secret</em>）使用公钥加密后发送给服务器Bob。</li><li>Bob收到Alice用公钥加密后的随机数（<em>pre-master secret</em>）后，使用自己的私钥进行解密。</li><li>到此，客户端Alice和服务器Bob都各自保留有三个随机数（<em>两个客户端生成的、一个服务器生成的</em>），双方使用这三个随机数生成一个「对话密钥」（<em>session key</em>），使用它来加密后续的对话，握手结束。</li></ol><br><blockquote><p>从上面的握手过程可以看出，服务器的私钥和公钥加密就是非对称加密RSA算法，它只会在建立连接的过程中使用一次，而关键作用就在于<u>对客户端给服务器发送的第三个随机数（<em>pre-master secret</em>）进行加密</u>，从而使生成的「对话密钥」安全性得到保障。而握手完成后的数据传输全部靠这把「对话密钥」进行加密，这也就是对称加密。非对称加密的效率低资源消耗大，所以只使用一次来建立连接，而数据的大量传输使用对称加密速度快资源消耗小；对称加密的协商和生成在线路传输上有被盗风险，而使用非对称加密来保护对称加密的生成过程来避免暴露。综上所述，我们利用了对称加密和非对称加密各自的优点分别来弥补对方的缺点，合理地配合使用加密算法。</p></blockquote><br><h5 id="这里需要解释一下为什么一定要用-三个-随机数来生成「对话密钥」："><a href="#这里需要解释一下为什么一定要用-三个-随机数来生成「对话密钥」：" class="headerlink" title="这里需要解释一下为什么一定要用 三个 随机数来生成「对话密钥」："></a>这里需要解释一下为什么一定要用 三个 随机数来生成「对话密钥」：</h5><ol><li>首先随机数的引入，很大程度提高了SSL/TLS协议的安全性。因为证书是静态的，而一尘不变肯定没有随机变化更让人难以揣测，这就好比我们平时登录帐号时使用的「密码」和「验证码」的区别，密码是静态的（<em>当然不是不能修改的意思</em>），而验证码是实时变化的。所以引入随机因素能够保证协商生成出来的密钥的随机性。</li><li>而引入的主要随机数就是被加密传输的第三个随机数（<em>pre-master secret</em>），那前面在客户端和服务器「打招呼」中生成的两个随机数有什么用呢？因为我们不能保证通信的双方主机之一（<em>客户端或服务器</em>）能正常生成「真正随机」的随机数，如果生成的唯一的随机数（pre-master secret）并不随机，就很可能被破解。这样在双方都参与的情况下生成三个随机数，三个随机数都不随机的情况发生的概率几乎为0，因为这种情况本身就很随机。</li></ol><br><br><h4 id="CloudFlare与SSL"><a href="#CloudFlare与SSL" class="headerlink" title="CloudFlare与SSL"></a>CloudFlare与SSL</h4><br><h5 id="CDN（Content-Distribution-Network）内容分发网络"><a href="#CDN（Content-Distribution-Network）内容分发网络" class="headerlink" title="CDN（Content Distribution Network）内容分发网络"></a>CDN（<em>Content Distribution Network</em>）内容分发网络</h5><p>内容分发网络CDN是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地讲影音、图片、应用程序等文件发送给用户，提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p><strong>CloudFlare</strong>就是知名的CDN服务提供商，在全球拥有许多连线到互联网交换点的连线，CloudFlare将网站内容缓存到自己的服务器上，以扮演内容提供网络（<em>CDN</em>）的角色，所有要求会透过CloudFlare进行反向代理，并直接从CloudFlare提供缓存的内容。</p><p>CloudFlare在14年9月发布了一种新型加密传输技术——<strong>无密钥SSL</strong>（<em>Keyless SSL</em>）。在该技术的支持下，CloudFlare可以在不持有客户私钥的情况下与访客创建SSL连接，这使得银行这种无法交予私钥的服务器用户现在也可以享受最大限度的安全服务。</p><br><h5 id="CloudFlare官方介绍"><a href="#CloudFlare官方介绍" class="headerlink" title="CloudFlare官方介绍"></a>CloudFlare官方介绍</h5><br><h6 id="①不使用「Keyless-SSL」的SSL握手过程（RSA）："><a href="#①不使用「Keyless-SSL」的SSL握手过程（RSA）：" class="headerlink" title="①不使用「Keyless SSL」的SSL握手过程（RSA）："></a>①不使用「Keyless SSL」的SSL握手过程（<em>RSA</em>）：</h6><p>也就是前面讲过的最原始的SSL协议运行过程，下图的「Visitor」就是「Alice」，「CloudFlare」就是「Bob」。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdfymvp5g6j30t80j0mz4.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>这种情况就是CloudFlare来代替内容提供商向客户端用户发送内容，而CloudFlare必须要拿到内容提供商的私钥，才能和客户端用户建立SSL安全连接。</p></blockquote><br><h6 id="②使用「Keyless-SSL」的SSL握手过程（RSA）："><a href="#②使用「Keyless-SSL」的SSL握手过程（RSA）：" class="headerlink" title="②使用「Keyless SSL」的SSL握手过程（RSA）："></a>②使用「Keyless SSL」的SSL握手过程（<em>RSA</em>）：</h6><p>使用CloudFlare的「Keyless SSL」后，当需要使用私钥解密的时候，再请求源服务器（<em>内容提供商</em>）用私钥解密，解密后再回送给CloudFlare服务器：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdgt9b9zirj30qo09lmxg.jpg" srcset="/img/loading.gif" alt=""></p><p>其具体的实现细节如下图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdfyzznm3ij31rv0u0jwo.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>看不清可以点开图片开大图</p></blockquote><p>前面说到，在SSL握手过程中，服务器的公钥和私钥只用到了一次，而这便是「Keyless」能运作的关键。</p><p>在CloudFlare收到客户端发来的用公钥加密的第三个随机数（<em>pre-master secret</em>）后，将它转发给内容提供商存放私钥的服务器，私钥服务器解密后发回给CloudFlare服务器，便可以继续进行后面的操作。</p><p>要用「Alice」和「Bob」来解释，就如下图：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdguol5mafg30vl0lhq4l.gif" srcset="/img/loading.gif" alt=""></p><br><br><br><br><br><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p>阮一峰老师博客：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS运行机制概述</a> 、<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a></p><p>掘金博客：<a href="https://juejin.im/post/5abb6c8651882555784e051d" target="_blank" rel="noopener">对称加密与非对称加密</a>、<a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="noopener">HTTP与HTTPS</a></p><p>CloudFlare官网博客：<a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">Keyless SSL: The Nitty Gritty Technical Details</a>、<a href="https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/" target="_blank" rel="noopener">Announcing Keyless SSL™: All the Benefits of CloudFlare Without Having to Turn Over Your Private SSL Keys</a></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>technology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java：访问修饰符及相关概念</title>
    <link href="/2020/03/10/Java:%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2020/03/10/Java:%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Java：访问修饰符及相关概念"><a href="#Java：访问修饰符及相关概念" class="headerlink" title="Java：访问修饰符及相关概念"></a>Java：访问修饰符及相关概念</h1><br><h2 id="四个修饰符基本概念"><a href="#四个修饰符基本概念" class="headerlink" title="四个修饰符基本概念"></a>四个修饰符基本概念</h2><br><h3 id="访问权限："><a href="#访问权限：" class="headerlink" title="访问权限："></a>访问权限：</h3><p><strong>public &gt; protected &gt; default &gt; private</strong></p><br><ul><li>public ——访问权限最大的修饰符，被它修饰的类、属性和方法可以在本类内部、别的类中以及别的包中使用。</li><li>protected ——访问权限介于public和private之间，被它修饰的属性和方法能被本类内部、本包中的其他类以及继承于本类的子类（子类可以是在别的包）使用。</li><li>default ——使用时可以省略（即在定义属性和方法时如果不加任何修饰符就等于使用default修饰）。它和protected修饰符的唯一区别就是protected可以被别的包中继承与本类的子类使用，而default只要是别的包的类（无论是不是子类）都不能使用。</li><li>private ——访问权限最小的修饰符，被它修饰的属性和方法只能用于本类内部。</li></ul><br><blockquote><p>这里有一点要注意，一个类中有一个用protected修饰的属性（方法也同理），继承于这个类但并不在同一个包中的子类能够使用它这个父类中的这个属性（protected）。</p></blockquote><br><br><blockquote><p>在定义属性和方法时，应尽量使用访问权限小修饰词，根据情况权限给到够用就行</p></blockquote><br><h2 id="静态-static"><a href="#静态-static" class="headerlink" title="静态 static"></a>静态 static</h2><ul><li>静态变量</li></ul><p>类中的静态变量是不属于类的对象或实例的，只能以<code>[类名].[变量名]</code>这样的方式使用。定义静态变量时常和final一起使用，表示一个全局通用的恒量。</p><ul><li>静态方法</li></ul><p>静态方法同样也是不属于类的对象或实例，也只能以<code>[类名].[方法名]</code>的方式使用。静态方法内部只能调用静态变量和静态方法，Java中工具类中有很多静态方法。</p><ul><li>静态类</li></ul><p>Java中静态类是不能作为顶层类的，只能作为内部类（嵌套类）使用，也就是静态内部类。由于有了静态和内部双身份，导致它比较特殊，有以下几个特点：</p><ol><li>静态内部类里的静态成员（变量或方法）可以在外部类没有创建对象或实例时被别的类调用，这一点是静态类的体现，调用方式：<code>[外部类].[静态内部类].[静态成员]</code>。</li><li>静态内部类里可以有非静态的成员，调用的方式便是通过创建<strong>内部类的对象</strong>来调用。<em>这里需要注意，外部类拥有调用内部类所有成员（包括private成员）的权限，至于内部类是非静态还是静态的区别也就是对应在外部类调用时要创建内部类对象和不用创建内部类对象的区别。</em></li><li>静态内部类可以引用外部类的成员，但必须是静态的成员。</li><li>非静态内部类里面是不能定义静态成员的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>technology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/03/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/03/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="写点什么，记录一下"><a href="#写点什么，记录一下" class="headerlink" title="写点什么，记录一下"></a>写点什么，记录一下</h3><p>作为一个不善言辞，从小就对文字语言不感冒的人，一直以来都是被动的输入，很少想着主动输出点什么（确实也没什么好说的…），但偶尔也会莫名其妙想写点东西。而博客这个早在我只知道上网能打游戏、聊天的时期就已经出现的词，这么个优雅的上网冲浪的方式，我居然到现在才真正用上它，哎，真不知道之前我都在网上瞎浪荡什么…以后这就是我的compose space了，想到什么就写点什么吧。</p>]]></content>
    
    
    <categories>
      
      <category>Journal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>personal</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
